const WORD_SIZE=32,generateBitmaskForPatternCharacters=t=>{let e={};for(let r of t)e[r]=0;for(let o=0;o<t.length;o++){let a=t.charAt(o);e[a]|=1<<t.length-o-1}return e},getScore=(t,{errors:e=0,currentLocation:r=0,expectedLocation:o=0,distance:a=100}={})=>{let s=e/t.length,c=Math.abs(o-r);return a?s+c/a:c?1:s},fuzzySearch=(t,e,r,o)=>{let{location:a,matchDistance:s,matchThreshold:c}=o;if(console.log(t,e,o),e.length>32)throw Error("Pattern too long to search for");let n=e.length,h=t.length,i=Math.max(0,Math.min(a,h)),l=c,_=t.indexOf(e,i);-1!=_&&(l=Math.min(getScore(e,{errors:0,currentLocation:_,expectedLocation:i,matchDistance:s}),l),-1!=(_=t.lastIndexOf(e,a+n))&&(l=Math.min(getScore(e,{errors:0,currentLocation:_,expectedLocation:i,matchDistance:s}),l)));let $=1<<n-1;_=-1;let g=1,f=n+h,u=[],m=[];for(let S=0;S<n;S+=1){let k=0,p=f;for(;k<p;){let x=getScore(e,{errors:S,currentLocation:i+p,expectedLocation:i,matchDistance:s});x<=l?k=p:f=p,p=Math.floor((f-k)/2+k)}f=p;let b=Math.max(1,i-p+1),L=Math.min(i+p,h)+n,M=Array(L+2);M[L+1]=(1<<S)-1;for(let P=L;P>=b;P-=1){let w=0;if(w=h<=P-1?0:r[t.charAt(P-1)],M[P]=(M[P+1]<<1|1)&w,S&&(M[P]|=(u[P+1]|u[P])<<1|1|u[P+1]),M[P]&$&&(g=getScore(e,{errors:S,currentLocation:P-1,expectedLocation:i,matchDistance:s}),m=[...m,{score:g,match:t.slice(P-1,P-1+n)},],g<=l)){if(l=g,(_=P-1)>a)b=Math.max(1,2*a-_);else break}}if(getScore(e,{errors:S+1,currentLocation:a,expectedLocation:i,matchDistance:s})>l)break;u=M}let z={isMatch:_>=0,score:Math.max(.001,g),bestLocation:_,possibleMatches:m};return console.log("Match => ",t.slice(_,_+n)),console.log("Possible Matches => ",m),z};class BitapSearch{constructor(t,e,r={matchThreshold:.6,matchDistance:100,location:0}){if(this.pattern=t.toLowerCase(),this.text=e.toLowerCase(),this.__chunks=[],this.options=r,!this.pattern.length)throw Error("Pattern cant be empty");let o=(t,e=0)=>{this.__chunks.push({pattern:t,bitmaskTable:generateBitmaskForPatternCharacters(t),startIndex:e})};if(t.length>32)throw Error("Pattern to big to search for");o(this.pattern)}search(){if(this.pattern===this.text)return{isMatch:!0,score:0};let{matchThreshold:t,matchDistance:e,location:r}=this.options,o=!1,a=0,s=[];this.__chunks.forEach(({pattern:c,bitmaskTable:n,startIndex:h})=>{let{isMatch:i,score:l,possibleMatches:_}=fuzzySearch(this.text,c,n,{location:r+h,matchDistance:e,matchThreshold:t});i&&(o=!0),a+=l,o&&(s=[...s,..._])});let c={isMatch:o,score:o?a/this.__chunks.length:1,allMatches:[...s]};return c}}